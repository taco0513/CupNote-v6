import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { SafeAreaView } from 'react-native-safe-area-context';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { colors, spacing, typography } from '../../styles/theme';
import { Card, Button, ProgressBar, Badge, HeaderBar } from '../../components/common';
import useStore from '../../store/useStore';
import type { TastingFlowNavigationProp, TastingFlowRouteProp } from '../../types/navigation';

// 디바운스 훅
const useDebounce = <T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T => {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  const debouncedCallback = useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        callback(...args);
      }, delay);
    },
    [callback, delay]
  ) as T;

  return debouncedCallback;
};

export const PersonalNotes: React.FC = () => {
  const navigation = useNavigation<TastingFlowNavigationProp>();
  const route = useRoute<TastingFlowRouteProp<'PersonalNotes'>>();
  const { setTastingFlowData, tastingFlowData } = useStore();
  
  // Safe params with fallback
  const params = route.params || { mode: 'cafe' as const };
  
  // 현재 스크린 저장
  useEffect(() => {
    setTastingFlowData({ currentScreen: 'PersonalNotes' });
  }, []);

  // 상태 관리
  const [commentText, setCommentText] = useState('');
  const [autoSaveStatus, setAutoSaveStatus] = useState<'saving' | 'saved' | 'error'>('saved');
  const [autoSaveCount, setAutoSaveCount] = useState(0);
  const [lastSavedAt, setLastSavedAt] = useState<Date | null>(null);
  const [autoGenerated, setAutoGenerated] = useState(false);

  // 자동 문장 생성 함수
  const generateAutoSummary = useCallback(() => {
    const sentences: string[] = [];
    
    // 향미 문장 생성
    if (tastingFlowData?.flavors && tastingFlowData.flavors.length > 0) {
      const flavorCount = tastingFlowData.flavors.length;
      const mainFlavors = tastingFlowData.flavors.slice(0, 3).join(', ');
      
      if (flavorCount === 1) {
        sentences.push(`${tastingFlowData.flavors[0]}의 향미가 돋보였습니다.`);
      } else if (flavorCount === 2) {
        sentences.push(`${tastingFlowData.flavors[0]}와 ${tastingFlowData.flavors[1]}의 향미가 느껴졌습니다.`);
      } else {
        sentences.push(`${mainFlavors} 등 ${flavorCount}가지 다양한 향미가 느껴졌습니다.`);
      }
    }
    
    // 감각 표현 문장 생성
    if (tastingFlowData?.sensoryExpressions && tastingFlowData.sensoryExpressions.length > 0) {
      const expressions = tastingFlowData.sensoryExpressions;
      const expressionCount = expressions.length;
      
      if (expressionCount === 1) {
        sentences.push(`${expressions[0]}한 느낌이었습니다.`);
      } else if (expressionCount === 2) {
        sentences.push(`${expressions[0]}하면서도 ${expressions[1]}한 특징이 있었습니다.`);
      } else {
        const mainExpressions = expressions.slice(0, 2).join('하고 ');
        sentences.push(`${mainExpressions}한 매력적인 커피였습니다.`);
      }
    }
    
    // 수치 평가 문장 생성
    if (tastingFlowData?.ratings) {
      const { acidity, sweetness, bitterness, body, balance } = tastingFlowData.ratings;
      const ratingsSentences: string[] = [];
      
      // 산미 평가
      if (acidity > 0) {
        if (acidity >= 4) {
          ratingsSentences.push('밝고 생기있는 산미');
        } else if (acidity >= 3) {
          ratingsSentences.push('적당한 산미');
        } else if (acidity >= 2) {
          ratingsSentences.push('부드러운 산미');
        }
      }
      
      // 단맛 평가
      if (sweetness > 0) {
        if (sweetness >= 4) {
          ratingsSentences.push('풍부한 단맛');
        } else if (sweetness >= 3) {
          ratingsSentences.push('은은한 단맛');
        }
      }
      
      // 바디감 평가
      if (body > 0) {
        if (body >= 4) {
          ratingsSentences.push('묵직한 바디감');
        } else if (body >= 3) {
          ratingsSentences.push('적당한 바디감');
        } else {
          ratingsSentences.push('가벼운 바디감');
        }
      }
      
      // 밸런스 평가
      if (balance >= 4) {
        ratingsSentences.push('훌륭한 밸런스');
      }
      
      if (ratingsSentences.length > 0) {
        if (ratingsSentences.length === 1) {
          sentences.push(`${ratingsSentences[0]}이 인상적이었습니다.`);
        } else {
          const lastRating = ratingsSentences.pop();
          sentences.push(`${ratingsSentences.join(', ')}와 ${lastRating}를 가진 커피였습니다.`);
        }
      }
    }
    
    return sentences.join(' ');
  }, [tastingFlowData]);

  // 글자 수 계산
  const characterCount = useMemo(() => commentText.length, [commentText]);
  const isOverLimit = characterCount > 200;

  // 자동 저장 함수
  const saveDraft = useCallback(async (text: string) => {
    try {
      setAutoSaveStatus('saving');
      const draftData = {
        commentText: text,
        timestamp: new Date().toISOString(),
      };
      await AsyncStorage.setItem('@personal_notes_draft', JSON.stringify(draftData));
      setAutoSaveStatus('saved');
      setLastSavedAt(new Date());
      setAutoSaveCount(prev => prev + 1);
    } catch (error) {
      console.error('Failed to save draft:', error);
      setAutoSaveStatus('error');
    }
  }, []);

  // 디바운스된 자동 저장
  const debouncedAutoSave = useDebounce(saveDraft, 10000); // 10초

  // 드래프트 불러오기 및 자동 문장 생성
  useEffect(() => {
    const loadDraft = async () => {
      try {
        const draftString = await AsyncStorage.getItem('@personal_notes_draft');
        if (draftString) {
          const draft = JSON.parse(draftString);
          setCommentText(draft.commentText || '');
        } else {
          // 드래프트가 없고 이전 데이터가 있으면 자동 문장 생성
          const autoSummary = generateAutoSummary();
          if (autoSummary) {
            setCommentText(autoSummary);
            setAutoGenerated(true);
          }
        }
      } catch (error) {
        console.error('Failed to load draft:', error);
        // 오류 발생 시에도 자동 문장 생성 시도
        const autoSummary = generateAutoSummary();
        if (autoSummary) {
          setCommentText(autoSummary);
          setAutoGenerated(true);
        }
      }
    };
    loadDraft();
  }, [generateAutoSummary]);

  // 텍스트 변경 핸들러
  const handleTextChange = useCallback((text: string) => {
    if (text.length <= 200) {
      setCommentText(text);
      debouncedAutoSave(text);
      // 사용자가 수정하면 자동 생성 플래그 해제
      if (autoGenerated) {
        setAutoGenerated(false);
      }
    }
  }, [debouncedAutoSave, autoGenerated]);

  // 다음 버튼 핸들러
  const handleNext = useCallback(async () => {
    // 드래프트 삭제
    try {
      await AsyncStorage.removeItem('@personal_notes_draft');
    } catch (error) {
      console.error('Failed to clear draft:', error);
    }

    // Zustand store에 데이터 저장
    setTastingFlowData({ 
      personalNotes: {
        notes: commentText.trim(),
        overallRating: 4.5, // TODO: Get from rating component
        shareToCommnity: false, // TODO: Get from user preference
      }
    });

    // 다음 화면으로 이동
    navigation.navigate('Result', params);
  }, [commentText, navigation, params, setTastingFlowData]);

  // 자동 저장 상태 표시 텍스트
  const getAutoSaveText = () => {
    if (autoSaveStatus === 'saving') return '저장 중...';
    if (autoSaveStatus === 'error') return '저장 실패';
    if (lastSavedAt) {
      const seconds = Math.floor((Date.now() - lastSavedAt.getTime()) / 1000);
      if (seconds < 60) return `${seconds}초 전 자동 저장됨`;
      const minutes = Math.floor(seconds / 60);
      return `${minutes}분 전 자동 저장됨`;
    }
    return '자동 저장 대기 중';
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <HeaderBar
        title="개인 노트"
        subtitle={params.mode === 'cafe' ? '☕ 카페 모드' : '🏠 홈카페 모드'}
        onBack={() => navigation.goBack()}
        progress={params.mode === 'cafe' ? 0.86 : 0.875}
        showProgress={true}
      />
      
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoid}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >


          {/* 자동 생성 알림 */}
          {autoGenerated && (
            <Card style={styles.autoGeneratedInfo} variant="outlined">
              <View style={styles.autoGeneratedContent}>
                <View style={styles.autoGeneratedHeader}>
                  <Text style={styles.autoGeneratedIcon}>✨</Text>
                  <Text style={styles.autoGeneratedTitle}>이전 선택을 바탕으로 자동 생성된 내용입니다</Text>
                </View>
                <Text style={styles.autoGeneratedSubtext}>
                  자유롭게 수정하거나 추가해주세요!
                </Text>
                <TouchableOpacity 
                  onPress={() => {
                    setCommentText('');
                    setAutoGenerated(false);
                  }}
                  style={styles.clearButton}
                  activeOpacity={0.7}
                >
                  <Text style={styles.clearButtonText}>초기화</Text>
                </TouchableOpacity>
              </View>
            </Card>
          )}

          {/* 메인 입력 영역 */}
          <Card style={styles.inputSection}>
            <TextInput
              style={[
                styles.textArea,
                isOverLimit && styles.textAreaError
              ]}
              value={commentText}
              onChangeText={handleTextChange}
              placeholder=""
              placeholderTextColor={colors.gray[500]}
              multiline
              maxLength={200}
              textAlignVertical="top"
            />
            <View style={styles.textAreaFooter}>
              <Text style={[
                styles.characterCount,
                isOverLimit && styles.characterCountError
              ]}>
                {characterCount}/200
              </Text>
              <Badge 
                text={getAutoSaveText()}
                variant={autoSaveStatus === 'saved' ? 'success' : 
                         autoSaveStatus === 'saving' ? 'warning' : 'error'}
                size="small"
              />
            </View>
          </Card>



        </ScrollView>

        {/* 하단 버튼 */}
        <View style={styles.footer}>
          <Button
            title="완료"
            onPress={handleNext}
            variant="primary"
            size="large"
            fullWidth
          />
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
  },
  keyboardAvoid: {
    flex: 1,
  },
  scrollContent: {
    paddingTop: spacing.lg,
    paddingBottom: spacing.xl,
  },
  inputSection: {
    marginHorizontal: spacing.lg,
    marginBottom: spacing.xl,
    padding: spacing.lg,
  },
  textArea: {
    minHeight: 120,
    maxHeight: 200,
    fontSize: typography.fontSize.md,
    color: colors.text.primary,
    lineHeight: 24,
  },
  textAreaError: {
    borderColor: colors.error,
  },
  textAreaFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: spacing.sm,
    paddingTop: spacing.sm,
    borderTopWidth: 1,
    borderTopColor: colors.gray[100],
  },
  characterCount: {
    fontSize: typography.fontSize.sm,
    color: colors.gray[600],
  },
  characterCountError: {
    color: colors.error,
  },
  footer: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderTopWidth: 1,
    borderTopColor: colors.gray[100],
  },
  autoGeneratedInfo: {
    marginHorizontal: spacing.lg,
    marginBottom: spacing.xl,
    padding: spacing.lg,
    backgroundColor: colors.secondaryLight,
    borderColor: colors.primary,
    borderWidth: 1,
  },
  autoGeneratedContent: {
    gap: spacing.sm,
  },
  autoGeneratedHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
  },
  autoGeneratedIcon: {
    fontSize: typography.fontSize.lg,
  },
  autoGeneratedTitle: {
    fontSize: typography.fontSize.md,
    fontWeight: typography.fontWeight.semibold as any,
    color: colors.text.primary,
    flex: 1,
  },
  autoGeneratedSubtext: {
    fontSize: typography.fontSize.sm,
    color: colors.gray[600],
    marginLeft: spacing.xl + spacing.sm,
  },
  clearButton: {
    alignSelf: 'flex-start',
    marginLeft: spacing.xl + spacing.sm,
    marginTop: spacing.xs,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.xs,
    backgroundColor: colors.white,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: colors.gray[300],
  },
  clearButtonText: {
    fontSize: typography.fontSize.sm,
    color: colors.primary,
    fontWeight: typography.fontWeight.medium as any,
  },
});

export default PersonalNotes;