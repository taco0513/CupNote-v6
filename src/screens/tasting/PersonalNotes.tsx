import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { SafeAreaView } from 'react-native-safe-area-context';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { colors, spacing, typography } from '../../styles/theme';
import { Card, Button, ProgressBar, Badge, HeaderBar } from '../../components/common';
import useStore from '../../store/useStore';
import type { TastingFlowNavigationProp, TastingFlowRouteProp } from '../../types/navigation';

// ë””ë°”ìš´ìŠ¤ í›…
const useDebounce = <T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T => {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  const debouncedCallback = useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        callback(...args);
      }, delay);
    },
    [callback, delay]
  ) as T;

  return debouncedCallback;
};

export const PersonalNotes: React.FC = () => {
  const navigation = useNavigation<TastingFlowNavigationProp>();
  const route = useRoute<TastingFlowRouteProp<'PersonalNotes'>>();
  const { setTastingFlowData, tastingFlowData } = useStore();
  
  // Safe params with fallback
  const params = route.params || { mode: 'cafe' as const };
  
  // í˜„ì¬ ìŠ¤í¬ë¦° ì €ì¥
  useEffect(() => {
    setTastingFlowData({ currentScreen: 'PersonalNotes' });
  }, []);

  // ìƒíƒœ ê´€ë¦¬
  const [commentText, setCommentText] = useState('');
  const [autoSaveStatus, setAutoSaveStatus] = useState<'saving' | 'saved' | 'error'>('saved');
  const [autoSaveCount, setAutoSaveCount] = useState(0);
  const [lastSavedAt, setLastSavedAt] = useState<Date | null>(null);
  const [autoGenerated, setAutoGenerated] = useState(false);

  // ìë™ ë¬¸ì¥ ìƒì„± í•¨ìˆ˜
  const generateAutoSummary = useCallback(() => {
    const sentences: string[] = [];
    
    // í–¥ë¯¸ ë¬¸ì¥ ìƒì„±
    if (tastingFlowData?.flavors && tastingFlowData.flavors.length > 0) {
      const flavorCount = tastingFlowData.flavors.length;
      const mainFlavors = tastingFlowData.flavors.slice(0, 3).join(', ');
      
      if (flavorCount === 1) {
        sentences.push(`${tastingFlowData.flavors[0]}ì˜ í–¥ë¯¸ê°€ ë‹ë³´ì˜€ìŠµë‹ˆë‹¤.`);
      } else if (flavorCount === 2) {
        sentences.push(`${tastingFlowData.flavors[0]}ì™€ ${tastingFlowData.flavors[1]}ì˜ í–¥ë¯¸ê°€ ëŠê»´ì¡ŒìŠµë‹ˆë‹¤.`);
      } else {
        sentences.push(`${mainFlavors} ë“± ${flavorCount}ê°€ì§€ ë‹¤ì–‘í•œ í–¥ë¯¸ê°€ ëŠê»´ì¡ŒìŠµë‹ˆë‹¤.`);
      }
    }
    
    // ê°ê° í‘œí˜„ ë¬¸ì¥ ìƒì„±
    if (tastingFlowData?.sensoryExpressions && tastingFlowData.sensoryExpressions.length > 0) {
      const expressions = tastingFlowData.sensoryExpressions;
      const expressionCount = expressions.length;
      
      if (expressionCount === 1) {
        sentences.push(`${expressions[0]}í•œ ëŠë‚Œì´ì—ˆìŠµë‹ˆë‹¤.`);
      } else if (expressionCount === 2) {
        sentences.push(`${expressions[0]}í•˜ë©´ì„œë„ ${expressions[1]}í•œ íŠ¹ì§•ì´ ìˆì—ˆìŠµë‹ˆë‹¤.`);
      } else {
        const mainExpressions = expressions.slice(0, 2).join('í•˜ê³  ');
        sentences.push(`${mainExpressions}í•œ ë§¤ë ¥ì ì¸ ì»¤í”¼ì˜€ìŠµë‹ˆë‹¤.`);
      }
    }
    
    // ìˆ˜ì¹˜ í‰ê°€ ë¬¸ì¥ ìƒì„±
    if (tastingFlowData?.ratings) {
      const { acidity, sweetness, bitterness, body, balance } = tastingFlowData.ratings;
      const ratingsSentences: string[] = [];
      
      // ì‚°ë¯¸ í‰ê°€
      if (acidity > 0) {
        if (acidity >= 4) {
          ratingsSentences.push('ë°ê³  ìƒê¸°ìˆëŠ” ì‚°ë¯¸');
        } else if (acidity >= 3) {
          ratingsSentences.push('ì ë‹¹í•œ ì‚°ë¯¸');
        } else if (acidity >= 2) {
          ratingsSentences.push('ë¶€ë“œëŸ¬ìš´ ì‚°ë¯¸');
        }
      }
      
      // ë‹¨ë§› í‰ê°€
      if (sweetness > 0) {
        if (sweetness >= 4) {
          ratingsSentences.push('í’ë¶€í•œ ë‹¨ë§›');
        } else if (sweetness >= 3) {
          ratingsSentences.push('ì€ì€í•œ ë‹¨ë§›');
        }
      }
      
      // ë°”ë””ê° í‰ê°€
      if (body > 0) {
        if (body >= 4) {
          ratingsSentences.push('ë¬µì§í•œ ë°”ë””ê°');
        } else if (body >= 3) {
          ratingsSentences.push('ì ë‹¹í•œ ë°”ë””ê°');
        } else {
          ratingsSentences.push('ê°€ë²¼ìš´ ë°”ë””ê°');
        }
      }
      
      // ë°¸ëŸ°ìŠ¤ í‰ê°€
      if (balance >= 4) {
        ratingsSentences.push('í›Œë¥­í•œ ë°¸ëŸ°ìŠ¤');
      }
      
      if (ratingsSentences.length > 0) {
        if (ratingsSentences.length === 1) {
          sentences.push(`${ratingsSentences[0]}ì´ ì¸ìƒì ì´ì—ˆìŠµë‹ˆë‹¤.`);
        } else {
          const lastRating = ratingsSentences.pop();
          sentences.push(`${ratingsSentences.join(', ')}ì™€ ${lastRating}ë¥¼ ê°€ì§„ ì»¤í”¼ì˜€ìŠµë‹ˆë‹¤.`);
        }
      }
    }
    
    return sentences.join(' ');
  }, [tastingFlowData]);

  // ê¸€ì ìˆ˜ ê³„ì‚°
  const characterCount = useMemo(() => commentText.length, [commentText]);
  const isOverLimit = characterCount > 200;

  // ìë™ ì €ì¥ í•¨ìˆ˜
  const saveDraft = useCallback(async (text: string) => {
    try {
      setAutoSaveStatus('saving');
      const draftData = {
        commentText: text,
        timestamp: new Date().toISOString(),
      };
      await AsyncStorage.setItem('@personal_notes_draft', JSON.stringify(draftData));
      setAutoSaveStatus('saved');
      setLastSavedAt(new Date());
      setAutoSaveCount(prev => prev + 1);
    } catch (error) {
      console.error('Failed to save draft:', error);
      setAutoSaveStatus('error');
    }
  }, []);

  // ë””ë°”ìš´ìŠ¤ëœ ìë™ ì €ì¥
  const debouncedAutoSave = useDebounce(saveDraft, 10000); // 10ì´ˆ

  // ë“œë˜í”„íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° ë° ìë™ ë¬¸ì¥ ìƒì„±
  useEffect(() => {
    const loadDraft = async () => {
      try {
        const draftString = await AsyncStorage.getItem('@personal_notes_draft');
        if (draftString) {
          const draft = JSON.parse(draftString);
          setCommentText(draft.commentText || '');
        } else {
          // ë“œë˜í”„íŠ¸ê°€ ì—†ê³  ì´ì „ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìë™ ë¬¸ì¥ ìƒì„±
          const autoSummary = generateAutoSummary();
          if (autoSummary) {
            setCommentText(autoSummary);
            setAutoGenerated(true);
          }
        }
      } catch (error) {
        console.error('Failed to load draft:', error);
        // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ìë™ ë¬¸ì¥ ìƒì„± ì‹œë„
        const autoSummary = generateAutoSummary();
        if (autoSummary) {
          setCommentText(autoSummary);
          setAutoGenerated(true);
        }
      }
    };
    loadDraft();
  }, [generateAutoSummary]);

  // í…ìŠ¤íŠ¸ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleTextChange = useCallback((text: string) => {
    if (text.length <= 200) {
      setCommentText(text);
      debouncedAutoSave(text);
      // ì‚¬ìš©ìê°€ ìˆ˜ì •í•˜ë©´ ìë™ ìƒì„± í”Œë˜ê·¸ í•´ì œ
      if (autoGenerated) {
        setAutoGenerated(false);
      }
    }
  }, [debouncedAutoSave, autoGenerated]);

  // ë‹¤ìŒ ë²„íŠ¼ í•¸ë“¤ëŸ¬
  const handleNext = useCallback(async () => {
    // ë“œë˜í”„íŠ¸ ì‚­ì œ
    try {
      await AsyncStorage.removeItem('@personal_notes_draft');
    } catch (error) {
      console.error('Failed to clear draft:', error);
    }

    // Zustand storeì— ë°ì´í„° ì €ì¥
    setTastingFlowData({ 
      personalNotes: {
        notes: commentText.trim(),
        overallRating: 4.5, // TODO: Get from rating component
        shareToCommnity: false, // TODO: Get from user preference
      }
    });

    // ë‹¤ìŒ í™”ë©´ìœ¼ë¡œ ì´ë™
    navigation.navigate('Result', params);
  }, [commentText, navigation, params, setTastingFlowData]);

  // ìë™ ì €ì¥ ìƒíƒœ í‘œì‹œ í…ìŠ¤íŠ¸
  const getAutoSaveText = () => {
    if (autoSaveStatus === 'saving') return 'ì €ì¥ ì¤‘...';
    if (autoSaveStatus === 'error') return 'ì €ì¥ ì‹¤íŒ¨';
    if (lastSavedAt) {
      const seconds = Math.floor((Date.now() - lastSavedAt.getTime()) / 1000);
      if (seconds < 60) return `${seconds}ì´ˆ ì „ ìë™ ì €ì¥ë¨`;
      const minutes = Math.floor(seconds / 60);
      return `${minutes}ë¶„ ì „ ìë™ ì €ì¥ë¨`;
    }
    return 'ìë™ ì €ì¥ ëŒ€ê¸° ì¤‘';
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <HeaderBar
        title="ê°œì¸ ë…¸íŠ¸"
        subtitle={params.mode === 'cafe' ? 'â˜• ì¹´í˜ ëª¨ë“œ' : 'ğŸ  í™ˆì¹´í˜ ëª¨ë“œ'}
        onBack={() => navigation.goBack()}
        progress={params.mode === 'cafe' ? 0.86 : 0.875}
        showProgress={true}
      />
      
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardAvoid}
      >
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >


          {/* ìë™ ìƒì„± ì•Œë¦¼ */}
          {autoGenerated && (
            <Card style={styles.autoGeneratedInfo} variant="outlined">
              <View style={styles.autoGeneratedContent}>
                <View style={styles.autoGeneratedHeader}>
                  <Text style={styles.autoGeneratedIcon}>âœ¨</Text>
                  <Text style={styles.autoGeneratedTitle}>ì´ì „ ì„ íƒì„ ë°”íƒ•ìœ¼ë¡œ ìë™ ìƒì„±ëœ ë‚´ìš©ì…ë‹ˆë‹¤</Text>
                </View>
                <Text style={styles.autoGeneratedSubtext}>
                  ììœ ë¡­ê²Œ ìˆ˜ì •í•˜ê±°ë‚˜ ì¶”ê°€í•´ì£¼ì„¸ìš”!
                </Text>
                <TouchableOpacity 
                  onPress={() => {
                    setCommentText('');
                    setAutoGenerated(false);
                  }}
                  style={styles.clearButton}
                  activeOpacity={0.7}
                >
                  <Text style={styles.clearButtonText}>ì´ˆê¸°í™”</Text>
                </TouchableOpacity>
              </View>
            </Card>
          )}

          {/* ë©”ì¸ ì…ë ¥ ì˜ì—­ */}
          <Card style={styles.inputSection}>
            <TextInput
              style={[
                styles.textArea,
                isOverLimit && styles.textAreaError
              ]}
              value={commentText}
              onChangeText={handleTextChange}
              placeholder=""
              placeholderTextColor={colors.gray[500]}
              multiline
              maxLength={200}
              textAlignVertical="top"
            />
            <View style={styles.textAreaFooter}>
              <Text style={[
                styles.characterCount,
                isOverLimit && styles.characterCountError
              ]}>
                {characterCount}/200
              </Text>
              <Badge 
                text={getAutoSaveText()}
                variant={autoSaveStatus === 'saved' ? 'success' : 
                         autoSaveStatus === 'saving' ? 'warning' : 'error'}
                size="small"
              />
            </View>
          </Card>



        </ScrollView>

        {/* í•˜ë‹¨ ë²„íŠ¼ */}
        <View style={styles.footer}>
          <Button
            title="ì™„ë£Œ"
            onPress={handleNext}
            variant="primary"
            size="large"
            fullWidth
          />
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
  },
  keyboardAvoid: {
    flex: 1,
  },
  scrollContent: {
    paddingTop: spacing.lg,
    paddingBottom: spacing.xl,
  },
  inputSection: {
    marginHorizontal: spacing.lg,
    marginBottom: spacing.xl,
    padding: spacing.lg,
  },
  textArea: {
    minHeight: 120,
    maxHeight: 200,
    fontSize: typography.fontSize.md,
    color: colors.text.primary,
    lineHeight: 24,
  },
  textAreaError: {
    borderColor: colors.error,
  },
  textAreaFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: spacing.sm,
    paddingTop: spacing.sm,
    borderTopWidth: 1,
    borderTopColor: colors.gray[100],
  },
  characterCount: {
    fontSize: typography.fontSize.sm,
    color: colors.gray[600],
  },
  characterCountError: {
    color: colors.error,
  },
  footer: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    backgroundColor: colors.white,
    borderTopWidth: 1,
    borderTopColor: colors.gray[100],
  },
  autoGeneratedInfo: {
    marginHorizontal: spacing.lg,
    marginBottom: spacing.xl,
    padding: spacing.lg,
    backgroundColor: colors.secondaryLight,
    borderColor: colors.primary,
    borderWidth: 1,
  },
  autoGeneratedContent: {
    gap: spacing.sm,
  },
  autoGeneratedHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
  },
  autoGeneratedIcon: {
    fontSize: typography.fontSize.lg,
  },
  autoGeneratedTitle: {
    fontSize: typography.fontSize.md,
    fontWeight: typography.fontWeight.semibold as any,
    color: colors.text.primary,
    flex: 1,
  },
  autoGeneratedSubtext: {
    fontSize: typography.fontSize.sm,
    color: colors.gray[600],
    marginLeft: spacing.xl + spacing.sm,
  },
  clearButton: {
    alignSelf: 'flex-start',
    marginLeft: spacing.xl + spacing.sm,
    marginTop: spacing.xs,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.xs,
    backgroundColor: colors.white,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: colors.gray[300],
  },
  clearButtonText: {
    fontSize: typography.fontSize.sm,
    color: colors.primary,
    fontWeight: typography.fontWeight.medium as any,
  },
});

export default PersonalNotes;